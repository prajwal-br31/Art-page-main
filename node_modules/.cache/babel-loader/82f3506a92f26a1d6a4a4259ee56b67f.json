{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/brundal/Documents/Website/Art-page-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/brundal/Documents/Website/Art-page-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/Users/brundal/Documents/Website/Art-page-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/Users/brundal/Documents/Website/Art-page-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/brundal/Documents/Website/Art-page-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar Transform = require('stream').Transform;\n\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\nvar MessageParser = /*#__PURE__*/function (_Transform) {\n  _inherits(MessageParser, _Transform);\n  function MessageParser(options) {\n    var _this;\n    _classCallCheck(this, MessageParser);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MessageParser).call(this, options));\n    _this.lastBytes = Buffer.alloc(4);\n    _this.headersParsed = false;\n    _this.headerBytes = 0;\n    _this.headerChunks = [];\n    _this.rawHeaders = false;\n    _this.bodySize = 0;\n    return _this;\n  }\n\n  /**\n   * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n   *\n   * @param {Buffer} data Next data chunk from the stream\n   */\n  _createClass(MessageParser, [{\n    key: \"updateLastBytes\",\n    value: function updateLastBytes(data) {\n      var lblen = this.lastBytes.length;\n      var nblen = Math.min(data.length, lblen);\n\n      // shift existing bytes\n      for (var i = 0, len = lblen - nblen; i < len; i++) {\n        this.lastBytes[i] = this.lastBytes[i + nblen];\n      }\n\n      // add new bytes\n      for (var _i = 1; _i <= nblen; _i++) {\n        this.lastBytes[lblen - _i] = data[data.length - _i];\n      }\n    }\n    /**\n     * Finds and removes message headers from the remaining body. We want to keep\n     * headers separated until final delivery to be able to modify these\n     *\n     * @param {Buffer} data Next chunk of data\n     * @return {Boolean} Returns true if headers are already found or false otherwise\n     */\n  }, {\n    key: \"checkHeaders\",\n    value: function checkHeaders(data) {\n      var _this2 = this;\n      if (this.headersParsed) {\n        return true;\n      }\n      var lblen = this.lastBytes.length;\n      var headerPos = 0;\n      this.curLinePos = 0;\n      for (var i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n        var chr = void 0;\n        if (i < lblen) {\n          chr = this.lastBytes[i];\n        } else {\n          chr = data[i - lblen];\n        }\n        if (chr === 0x0a && i) {\n          var pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n          var pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;\n          if (pr1 === 0x0a) {\n            this.headersParsed = true;\n            headerPos = i - lblen + 1;\n            this.headerBytes += headerPos;\n            break;\n          } else if (pr1 === 0x0d && pr2 === 0x0a) {\n            this.headersParsed = true;\n            headerPos = i - lblen + 1;\n            this.headerBytes += headerPos;\n            break;\n          }\n        }\n      }\n      if (this.headersParsed) {\n        this.headerChunks.push(data.slice(0, headerPos));\n        this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n        this.headerChunks = null;\n        this.emit('headers', this.parseHeaders());\n        if (data.length - 1 > headerPos) {\n          var chunk = data.slice(headerPos);\n          this.bodySize += chunk.length;\n          // this would be the first chunk of data sent downstream\n          setImmediate(function () {\n            return _this2.push(chunk);\n          });\n        }\n        return false;\n      } else {\n        this.headerBytes += data.length;\n        this.headerChunks.push(data);\n      }\n\n      // store last 4 bytes to catch header break\n      this.updateLastBytes(data);\n      return false;\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      if (!chunk || !chunk.length) {\n        return callback();\n      }\n      if (typeof chunk === 'string') {\n        chunk = Buffer.from(chunk, encoding);\n      }\n      var headersFound;\n      try {\n        headersFound = this.checkHeaders(chunk);\n      } catch (E) {\n        return callback(E);\n      }\n      if (headersFound) {\n        this.bodySize += chunk.length;\n        this.push(chunk);\n      }\n      setImmediate(callback);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      if (this.headerChunks) {\n        var chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n        this.bodySize += chunk.length;\n        this.push(chunk);\n        this.headerChunks = null;\n      }\n      callback();\n    }\n  }, {\n    key: \"parseHeaders\",\n    value: function parseHeaders() {\n      var lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n      for (var i = lines.length - 1; i > 0; i--) {\n        if (/^\\s/.test(lines[i])) {\n          lines[i - 1] += '\\n' + lines[i];\n          lines.splice(i, 1);\n        }\n      }\n      return lines.filter(function (line) {\n        return line.trim();\n      }).map(function (line) {\n        return {\n          key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n          line: line\n        };\n      });\n    }\n  }]);\n  return MessageParser;\n}(Transform);\nmodule.exports = MessageParser;","map":null,"metadata":{},"sourceType":"script"}